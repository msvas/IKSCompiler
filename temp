diff --git a/include/iks_ast.h b/include/iks_ast.h
index 6446d50..3231d94 100644
--- a/include/iks_ast.h
+++ b/include/iks_ast.h
@@ -5,6 +5,10 @@
 */
 #ifndef __IKS_AST_H
 #define __IKS_AST_H
+
+#include <stdlib.h>
+#include <stdint.h>
+
 #define IKS_AST_PROGRAMA             0
 #define IKS_AST_FUNCAO               1
 #define IKS_AST_IF_ELSE              2
@@ -56,7 +60,45 @@
 #define IKS_ERROR_WRONG_PAR_OUTPUT	13
 #define IKS_ERROR_WRONG_PAR_RETURN	14
 
-
-
+static inline char *get_ast_node_type_str(uint32_t ntype)
+{
+	switch (ntype) {
+		case IKS_AST_PROGRAMA: return "programa";
+		case IKS_AST_FUNCAO: return "funcao";
+		case IKS_AST_IF_ELSE: return "ifelse";
+		case IKS_AST_DO_WHILE: return "dowhile";
+		case IKS_AST_WHILE_DO: return "whiledo";
+		case IKS_AST_INPUT: return "input";
+		case IKS_AST_OUTPUT: return "output";
+		case IKS_AST_ATRIBUICAO: return "=";
+		case IKS_AST_RETURN: return "return";
+		case IKS_AST_BLOCO: return "block";
+		case IKS_AST_IDENTIFICADOR: return "identificador";
+		case IKS_AST_LITERAL: return "literal";
+		case IKS_AST_ARIM_SOMA: return "+";
+		case IKS_AST_ARIM_SUBTRACAO: return "-";
+		case IKS_AST_ARIM_MULTIPLICACAO: return "*";
+		case IKS_AST_ARIM_DIVISAO: return "/";
+		case IKS_AST_ARIM_INVERSAO: return "-";
+		case IKS_AST_LOGICO_E: return "&&";
+		case IKS_AST_LOGICO_OU: return "||";
+		case IKS_AST_LOGICO_COMP_DIF: return "!=";
+		case IKS_AST_LOGICO_COMP_IGUAL: return "==";
+		case IKS_AST_LOGICO_COMP_LE: return "<=";
+		case IKS_AST_LOGICO_COMP_GE: return ">=";
+		case IKS_AST_LOGICO_COMP_L: return "<";
+		case IKS_AST_LOGICO_COMP_G: return ">";
+		case IKS_AST_LOGICO_COMP_NEGACAO: return "!";
+		case IKS_AST_VETOR_INDEXADO: return "[]";
+		case IKS_AST_CHAMADA_DE_FUNCAO: return "call";
+		default:
+			fprintf(stderr, "%s(%d): type %d provided is invalid here\n", __FILE__, __LINE__, ntype);
+			return "invalid";
+	}
+	/* never gets here */
+	fprintf(stderr, "%s(%d): should never reach this point\n", __FILE__, __LINE__);
+	abort();
+}
 
 #endif
+
diff --git a/parser.y b/parser.y
index acf0ba2..677e120 100644
--- a/parser.y
+++ b/parser.y
@@ -688,3 +688,19 @@ v_ident:		 identificador '[' expr ']'
 				$$ = insereNodo($3, $$);
 			};
 %%
+
+#define _GNU_SOURCE
+#include <stdio.h>
+
+extern int column;
+extern int yylineno;
+
+int yyerror(char *s)
+{
+	char *str;
+	fflush(stdout);
+	asprintf(&str, "line %d: %s", yylineno, s);
+	printf("\n%*s\n%*s\n", column, "^", column, str);
+	free(str);
+}
+
diff --git a/scanner.l b/scanner.l
index a1ccddb..8920741 100644
--- a/scanner.l
+++ b/scanner.l
@@ -11,8 +11,12 @@
 
 uint32_t line_cnt = 1;
 struct dict *dict = NULL;
+void count(void);
+void comment(void);
 %}
+
 %option yylineno
+
  /* int: an optional '-' signal followed by a digit that is optionally followed by zero or more digits */
 INT    (-*[[:digit:]])[[:digit:]]*
  /* character: starts with ''' that must not be directly followed by ''' or a new line (\n). The first part does't match the scape symbol which is treated in the second part */
@@ -21,19 +25,13 @@ CHAR   '([^'\\\n]|\\.)'
 STRING \"(\\.|[^"])*\"  
 ID     (_|[[:alpha:]])(_|[[:alnum:]])*
 
- /* This is a condition, when the scanner matches "/*" below it starts this condition */
-%x comment0
+ /* This is a condition, when the scanner matches "//" below it starts this condition */
 %x comment1
 
 %%
 
  /* Handle C style comments like this one */
-"/*"     BEGIN(comment0);
-<comment0>[^*\n]*                     /* Consume anything that is not a '*' */
-<comment0>"*"+[^*/\n]*                /* Ignore '*'s not followed by '/'s */
-<comment0>\n             ++line_cnt;  /* Commented lines are still lines. Count them. */
-<comment0>"*"+"/"        BEGIN(0);    /* End of comment found. Go back to initial condition and try to match a rule from begining (could be BEGIN(INITIAL) instead of BEGIN(0)). */
-
+"/*"     { comment(); }
 "//"     BEGIN(comment1);             /* start comment1 condition */
 <comment1>[^\n]+                      /* ignore everything on this line */
 <comment1>\n             ++line_cnt; BEGIN(0);
@@ -42,53 +40,50 @@ ID     (_|[[:alpha:]])(_|[[:alnum:]])*
 \n ++line_cnt;
 
  /* Reserved words */
-int     { yylval.symbol = install(yytext, (TK_PR_INT)   , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_INT);    }
-float   { yylval.symbol = install(yytext, (TK_PR_FLOAT) , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_FLOAT);  }
-bool    { yylval.symbol = install(yytext, (TK_PR_BOOL)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_BOOL);   }
-char    { yylval.symbol = install(yytext, (TK_PR_CHAR)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_CHAR);   }
-string  { yylval.symbol = install(yytext, (TK_PR_STRING), line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_STRING); }
-if      { yylval.symbol = install(yytext, (TK_PR_IF)    , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_IF);     }
-then    { yylval.symbol = install(yytext, (TK_PR_THEN)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_THEN);   }
-else    { yylval.symbol = install(yytext, (TK_PR_ELSE)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_ELSE);   }
-while   { yylval.symbol = install(yytext, (TK_PR_WHILE) , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_WHILE);  }
-do      { yylval.symbol = install(yytext, (TK_PR_DO)    , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_DO);     }
-input   { yylval.symbol = install(yytext, (TK_PR_INPUT) , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_INPUT);  }
-output  { yylval.symbol = install(yytext, (TK_PR_OUTPUT), line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_OUTPUT); }
-return  { yylval.symbol = install(yytext, (TK_PR_RETURN), line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_RETURN); }
+int     { count(); yylval.symbol = install(yytext, (TK_PR_INT)   , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_INT);    }
+float   { count(); yylval.symbol = install(yytext, (TK_PR_FLOAT) , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_FLOAT);  }
+bool    { count(); yylval.symbol = install(yytext, (TK_PR_BOOL)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_BOOL);   }
+char    { count(); yylval.symbol = install(yytext, (TK_PR_CHAR)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_CHAR);   }
+string  { count(); yylval.symbol = install(yytext, (TK_PR_STRING), line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_STRING); }
+if      { count(); yylval.symbol = install(yytext, (TK_PR_IF)    , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_IF);     }
+then    { count(); yylval.symbol = install(yytext, (TK_PR_THEN)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_THEN);   }
+else    { count(); yylval.symbol = install(yytext, (TK_PR_ELSE)  , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_ELSE);   }
+while   { count(); yylval.symbol = install(yytext, (TK_PR_WHILE) , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_WHILE);  }
+do      { count(); yylval.symbol = install(yytext, (TK_PR_DO)    , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_DO);     }
+input   { count(); yylval.symbol = install(yytext, (TK_PR_INPUT) , line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_INPUT);  }
+output  { count(); yylval.symbol = install(yytext, (TK_PR_OUTPUT), line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_OUTPUT); }
+return  { count(); yylval.symbol = install(yytext, (TK_PR_RETURN), line_cnt, dict);  debug("%s found at line %d", yytext, line_cnt); return (TK_PR_RETURN); }
 
  /* 
   * Special characters. Some of them must be scaped with
   * a backslash (or be the first or last in the list!)
   */
-[,;:()\[\]{}+\-*/<>=!&$] { yylval.symbol = install(yytext, (uint32_t)yytext[0], line_cnt, dict); debug("%c found at line %d", yytext[0], line_cnt); return yytext[0]; }
+[,;:()\[\]{}+\-*/<>=!&$] { count(); yylval.symbol = install(yytext, (uint32_t)yytext[0], line_cnt, dict); debug("%c found at line %d", yytext[0], line_cnt); return yytext[0]; }
 
  /* Relational operators */
-"<="    { yylval.symbol = install(yytext, (TK_OC_LE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_LE);     }
-">="    { yylval.symbol = install(yytext, (TK_OC_GE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_GE);     }
-"=="    { yylval.symbol = install(yytext, (TK_OC_EQ) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_EQ);     }
-"!="    { yylval.symbol = install(yytext, (TK_OC_NE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_NE);     }
-"&&"    { yylval.symbol = install(yytext, (TK_OC_AND), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_AND);    }
-"||"    { yylval.symbol = install(yytext, (TK_OC_OR) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_OR);     }
+"<="    { count(); yylval.symbol = install(yytext, (TK_OC_LE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_LE);     }
+">="    { count(); yylval.symbol = install(yytext, (TK_OC_GE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_GE);     }
+"=="    { count(); yylval.symbol = install(yytext, (TK_OC_EQ) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_EQ);     }
+"!="    { count(); yylval.symbol = install(yytext, (TK_OC_NE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_NE);     }
+"&&"    { count(); yylval.symbol = install(yytext, (TK_OC_AND), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_AND);    }
+"||"    { count(); yylval.symbol = install(yytext, (TK_OC_OR) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_OC_OR);     }
 
  /* Literals */
-{INT}                 { yylval.symbol = install(yytext, (TK_LIT_INT)  , line_cnt, dict); debug("%d found at line %d", atoi(yytext), line_cnt); return (TK_LIT_INT); }
-{INT}+"."[[:digit:]]+ { yylval.symbol = install(yytext, (TK_LIT_FLOAT), line_cnt, dict); debug("%f found at line %d", atof(yytext), line_cnt); return (TK_LIT_FLOAT); }
-"false"               { yylval.symbol = install(yytext, (TK_LIT_FALSE), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_FALSE); }
-"true"                { yylval.symbol = install(yytext, (TK_LIT_TRUE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_TRUE); }
-
- /* TODO: remove ' and " from char and string respectively */
-{CHAR}                { yylval.symbol = install(yytext, (TK_LIT_CHAR)  , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_CHAR); }
-{STRING}              { yylval.symbol = install(yytext, (TK_LIT_STRING), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_STRING); }
+{INT}                 { count(); yylval.symbol = install(yytext, (TK_LIT_INT)  , line_cnt, dict); debug("%d found at line %d", atoi(yytext), line_cnt); return (TK_LIT_INT); }
+{INT}+"."[[:digit:]]+ { count(); yylval.symbol = install(yytext, (TK_LIT_FLOAT), line_cnt, dict); debug("%f found at line %d", atof(yytext), line_cnt); return (TK_LIT_FLOAT); }
+"false"               { count(); yylval.symbol = install(yytext, (TK_LIT_FALSE), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_FALSE); }
+"true"                { count(); yylval.symbol = install(yytext, (TK_LIT_TRUE) , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_TRUE); }
+{CHAR}                { count(); yylval.symbol = install(yytext, (TK_LIT_CHAR)  , line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_CHAR); }
+{STRING}              { count(); yylval.symbol = install(yytext, (TK_LIT_STRING), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_LIT_STRING); }
 
  /* Identifier */
-{ID}                  { yylval.symbol = install(yytext, (TK_IDENTIFICADOR), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_IDENTIFICADOR); }
+{ID}                  { count(); yylval.symbol = install(yytext, (TK_IDENTIFICADOR), line_cnt, dict); debug("%s found at line %d", yytext, line_cnt); return (TK_IDENTIFICADOR); }
 
 [ \t]+               /* ignore white spaces */
 
  /* Did not match any of above regex */
 .                     { debug("Invalid expression %s found in line %d", yytext, line_cnt, dict); return (TOKEN_ERRO); }
 
- /* TODO: implement line and colum counters */
 %%
 
 /**
@@ -106,8 +101,8 @@ int get_line(void)
  * Note:
  * On success the given file is used as input, otherwise
  * stdin.
+ * See also: yyrestart(yyin) (info flex --vi-keys)
  */
-//TODO: maybe use yyrestart(yyin) (see: info flex --vi-keys)
 void set_yyin(char *infile)
 {
 	int r = 0;
@@ -122,3 +117,34 @@ void set_yyin(char *infile)
 	}
 }
 
+void comment()
+{
+	char c;
+	char c1;
+
+loop:
+	while ((c = input()) != '*' && c != 0); /* consume all chars until '*' */
+
+	if ((c1 = input()) != '/' && c != 0) {
+		unput(c1);
+		goto loop;
+	}
+}
+
+int column = 0;
+
+void count()
+{
+	int i;
+	for (i = 0; yytext[i] != '\0'; i++) {
+		if (yytext[i] == '\n') {
+			column = 0;
+		} else if (yytext[i] == '\t') {
+			column += 8 - (column % 8);
+		} else {
+			column++;
+		}
+	}
+	ECHO;
+}
+
diff --git a/src/comp_tree.c b/src/comp_tree.c
index 07d4cba..78bceed 100644
--- a/src/comp_tree.c
+++ b/src/comp_tree.c
@@ -19,7 +19,7 @@ AST_TREE* criaNodo(int chave, comp_dict_item_t* tableEntry, int definedType) //c
 {
         AST_TREE* novoNodo;
 
-	debug("criando nodo chave = %d", chave);
+	debug("Criando nodo. Chave %d (%s)", chave, get_ast_node_type_str(chave));
 
         novoNodo = malloc(sizeof(AST_TREE));
         novoNodo->type = chave;
@@ -45,13 +45,13 @@ AST_TREE* criaNodo(int chave, comp_dict_item_t* tableEntry, int definedType) //c
 		case IKS_AST_LITERAL:
 		case IKS_AST_FUNCAO:
 			if (tableEntry == NULL) {
-				debug("Error! tableEntry is NULL! Should not be! (chave = %d)", chave);
+				debug("ERROR! tableEntry is NULL! Should not be! Chave %d (%s)", chave, get_ast_node_type_str(chave));
 				return NULL;
 			}
 			gv_declare(chave, novoNodo, tableEntry->key);
 			break;
 		default:
-			//debug("tableEntry is NULL! Ok! (chave = %d)", chave);
+			//debug("tableEntry is NULL! Ok! Chave %d (%s)", chave, get_ast_node_type_str(chave));
 			gv_declare(chave, novoNodo, NULL);
 			break;
 	}
diff --git a/src/main.c b/src/main.c
index e0ff7ae..8236d1c 100644
--- a/src/main.c
+++ b/src/main.c
@@ -6,20 +6,16 @@
 #include "main.h"
 #include "util.h"
 
-int yylineno;
-
-void yyerror(char const *mensagem)
-{
-	fprintf (stderr, "%s line: %i\n", mensagem, yylineno);
-}
-
-//TODO: exit(IKS_SYNTAX_OK) or exit(IKS_SYNTAX_SUCESSO)
-int main(char argv, int **argc)
+int main(int argc, char *argv[])
 {
 	int r;
+
 	gv_init("visual_tree.dot");
 	r = yyparse();
 	gv_close();
+
+	system("dot -Tpng visual_tree.dot -o visual_tree.png");
+
 	return r;
 }
 
